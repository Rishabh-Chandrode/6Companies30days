#1 Max Point on a line
    multiply instead of divide
    ((points[j][1]-points[i][1])*(points[i][0]-points[k][0])) == ((points[i][1]-points[k][1])*(points[j][0]-points[i][0]))

#2 valid square 
    take square instead of root(float);

#3 Trailing Zeros in factorial n

    n +  n  +   n    .......
    5   5*5   5*5*5

#4 Number of Boomerangs
    calculate no of points with same distance to a point 
    use permutation 

#5 Split Array into Consecutive Subsequences.cpp
    use two maps one for frequency and one for vacancy
    creates groups according to need

#6 Minimum Consecutive Cards to Pick Up
    store frequency using hashmap

#7 *

#8 Maximum Points in an Archery Competition
    use Recursion and backtracking to check all cases